import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

export const dynamic = 'force-dynamic'

function getSupabaseClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: {
        autoRefreshToken: false,
        persistSession: false,
      },
    }
  )
}

export async function POST(request: NextRequest) {
  try {
    console.log('üîç [verify-token] Starting token verification...')
    const supabase = getSupabaseClient()
    const { token } = await request.json()
    console.log('üìù [verify-token] Token received:', token ? `${token.substring(0, 8)}...` : 'null')

    if (!token) {
      console.error('‚ùå [verify-token] No token provided')
      return NextResponse.json({ error: '–¢–æ–∫–µ–Ω –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω' }, { status: 400 })
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–∫–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    console.log('üîé [verify-token] Looking up token in database...')
    const { data: authToken, error: tokenError } = await supabase
      .from('auth_tokens')
      .select('*')
      .eq('token', token)
      .single()

    if (tokenError) {
      console.error('‚ùå [verify-token] Token lookup error:', tokenError)
      return NextResponse.json({ error: '–ù–µ–≤–µ—Ä–Ω—ã–π –∏–ª–∏ –∏—Å—Ç–µ–∫—à–∏–π —Ç–æ–∫–µ–Ω', details: tokenError.message }, { status: 401 })
    }

    if (!authToken) {
      console.error('‚ùå [verify-token] Token not found')
      return NextResponse.json({ error: '–ù–µ–≤–µ—Ä–Ω—ã–π –∏–ª–∏ –∏—Å—Ç–µ–∫—à–∏–π —Ç–æ–∫–µ–Ω' }, { status: 401 })
    }

    console.log('‚úÖ [verify-token] Token found:', { telegram_id: authToken.telegram_id, used: authToken.used, expires_at: authToken.expires_at })

    if (authToken.used) {
      console.error('‚ùå [verify-token] Token already used')
      return NextResponse.json({ error: '–¢–æ–∫–µ–Ω —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω' }, { status: 401 })
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∏—Å—Ç—ë–∫ –ª–∏ —Ç–æ–∫–µ–Ω
    if (new Date(authToken.expires_at) < new Date()) {
      console.error('‚ùå [verify-token] Token expired:', authToken.expires_at)
      return NextResponse.json({ error: '–¢–æ–∫–µ–Ω –∏—Å—Ç—ë–∫' }, { status: 401 })
    }

    console.log('‚úÖ [verify-token] Token is valid, proceeding...')

    const email = `${authToken.telegram_id}@outlivion.local`
    console.log('üìß [verify-token] Generated email:', email)

    console.log('üîé [verify-token] Checking existing profile...')
    const { data: existingProfileByTelegram, error: profileFetchError } = await supabase
      .from('users')
      .select('*')
      .eq('telegram_id', authToken.telegram_id)
      .maybeSingle()

    if (profileFetchError) {
      console.error('‚ùå [verify-token] Profile fetch error:', profileFetchError)
      return NextResponse.json(
        { error: '–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –ø—Ä–æ—Ñ–∏–ª—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', details: profileFetchError.message },
        { status: 500 }
      )
    }

    console.log('‚úÖ [verify-token] Profile check done:', existingProfileByTelegram ? `Found user ${existingProfileByTelegram.id}` : 'No existing profile')

    type AdminUser = NonNullable<
      Awaited<ReturnType<typeof supabase.auth.admin.getUserById>>['data']['user']
    >

    let authUser: AdminUser | null = null
    let createdAuthUser = false

    if (existingProfileByTelegram?.id) {
      console.log('üîç [verify-token] Checking auth.users for existing profile ID:', existingProfileByTelegram.id)
      const { data: existingAuthUser } = await supabase.auth.admin.getUserById(existingProfileByTelegram.id)
      authUser = existingAuthUser?.user ?? null
      console.log('‚úÖ [verify-token] Auth user check:', authUser ? 'Found' : 'Not found')
    }

    if (!authUser) {
      console.log('üîç [verify-token] Searching existing auth users...')
      // –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è—Ö
      const { data: listData, error: listError } = await supabase.auth.admin.listUsers({ page: 1, perPage: 1000 })
      
      if (!listError && listData?.users) {
        console.log(`üìã [verify-token] Found ${listData.users.length} auth users, searching...`)
        const matchedUser = listData.users.find(
          (user) =>
            user.email?.toLowerCase() === email.toLowerCase() ||
            user.user_metadata?.telegram_id === authToken.telegram_id
        )
        
        if (matchedUser) {
          authUser = matchedUser as AdminUser
          console.log('‚úÖ [verify-token] Found existing auth user by email or telegram_id:', authUser.id)
        }
      } else if (listError) {
        console.error('‚ùå [verify-token] Error listing users:', listError)
      }
    }

    if (!authUser) {
      console.log('üÜï [verify-token] Creating new auth user...')
      // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º email
      const uniqueEmail = `${authToken.telegram_id}-${Date.now()}@outlivion.local`
      
      const { data: createdAuthResponse, error: authCreateError } = await supabase.auth.admin.createUser({
        email: uniqueEmail,
        password: token,
        email_confirm: true,
        user_metadata: {
          telegram_id: authToken.telegram_id,
        },
      })

      if (authCreateError) {
        console.error('‚ùå [verify-token] Auth creation error:', authCreateError)
        return NextResponse.json(
          { error: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', details: authCreateError.message },
          { status: 500 }
        )
      }

      if (createdAuthResponse?.user) {
        authUser = createdAuthResponse.user
        createdAuthUser = true
        console.log('‚úÖ [verify-token] Auth user created:', authUser.id)
      }
    }

    if (!authUser) {
      console.error('‚ùå [verify-token] No auth user after all attempts')
      return NextResponse.json({ error: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' }, { status: 500 })
    }

    console.log('‚úÖ [verify-token] Auth user ready:', authUser.id)

    if (!createdAuthUser) {
      console.log('üîÑ [verify-token] Updating password for existing user...')
      const { error: updatePasswordError } = await supabase.auth.admin.updateUserById(authUser.id, {
        password: token,
        user_metadata: {
          telegram_id: authToken.telegram_id,
        },
      })

      if (updatePasswordError) {
        console.error('‚ùå [verify-token] Auth update error:', updatePasswordError)
      }
    }

    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ—Ñ–∏–ª—å –≤ —Ç–∞–±–ª–∏—Ü–µ users
    console.log('üë§ [verify-token] Syncing user profile...')
    let userData = null

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —É–∂–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    if (existingProfileByTelegram && existingProfileByTelegram.id === authUser.id) {
      console.log('‚úÖ [verify-token] Profile already in sync')
      userData = existingProfileByTelegram
    } else if (existingProfileByTelegram && existingProfileByTelegram.id !== authUser.id) {
      console.log(`üîÑ [verify-token] Profile ID mismatch, migrating from ${existingProfileByTelegram.id} to ${authUser.id}`)
      const oldId = existingProfileByTelegram.id

      const relationsToUpdate = [
        { table: 'codes', column: 'used_by' },
        { table: 'referrals', column: 'referrer_id' },
        { table: 'referrals', column: 'referred_id' },
        { table: 'transactions', column: 'user_id' },
        { table: 'payments', column: 'user_id' },
      ]

      for (const relation of relationsToUpdate) {
        const { error: relationError } = await supabase
          .from(relation.table)
          .update({ [relation.column]: authUser.id })
          .eq(relation.column, oldId)

        if (relationError) {
          console.error(`‚ùå [verify-token] Failed to migrate ${relation.table}.${relation.column}`, relationError)
          return NextResponse.json(
            { error: '–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', details: relationError.message },
            { status: 500 }
          )
        }
      }

      const { data: migratedProfile, error: migrateError } = await supabase
        .from('users')
        .update({ id: authUser.id })
        .eq('id', oldId)
        .select()
        .single()

      if (migrateError) {
        console.error('‚ùå [verify-token] Profile migration error:', migrateError)
        return NextResponse.json(
          { error: '–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', details: migrateError.message },
          { status: 500 }
        )
      }

      userData = migratedProfile
      console.log('‚úÖ [verify-token] Profile migrated')
    } else {
      // –ü—Ä–æ—Ñ–∏–ª—è —Å–æ–≤—Å–µ–º –Ω–µ—Ç - —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π
      console.log('üÜï [verify-token] Creating new profile for auth user:', authUser.id)
      const { data: createdProfile, error: createProfileError } = await supabase
        .from('users')
        .insert({
          id: authUser.id,
          telegram_id: authToken.telegram_id,
        })
        .select()
        .single()

      if (createProfileError || !createdProfile) {
        console.error('‚ùå [verify-token] Profile creation error:', createProfileError)
        return NextResponse.json(
          { error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', details: createProfileError?.message },
          { status: 500 }
        )
      }

      userData = createdProfile
      console.log('‚úÖ [verify-token] Profile created:', userData.id)
    }

    // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ telegram_id –∞–∫—Ç—É–∞–ª–µ–Ω
    if (userData.telegram_id !== authToken.telegram_id) {
      const { data: alignedProfile, error: alignError } = await supabase
        .from('users')
        .update({ telegram_id: authToken.telegram_id })
        .eq('id', authUser.id)
        .select()
        .single()

      if (!alignError && alignedProfile) {
        userData = alignedProfile
      }
    }

    // –ü–æ–º–µ—á–∞–µ–º —Ç–æ–∫–µ–Ω –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π
    console.log('üîÑ [verify-token] Marking token as used...')
    await supabase
      .from('auth_tokens')
      .update({ used: true })
      .eq('token', token)

    console.log('üîê [verify-token] Creating session for user...')
    // –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏—Å–ø–æ–ª—å–∑—É—è –ø–∞—Ä–æ–ª—å = —Ç–æ–∫–µ–Ω
    const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({
      email: authUser.email!,
      password: token,
    })

    if (signInError || !signInData.session) {
      console.error('‚ùå [verify-token] Failed to create session:', signInError)
      return NextResponse.json(
        { error: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å–µ—Å—Å–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', details: signInError?.message },
        { status: 500 }
      )
    }

    console.log('‚úÖ [verify-token] Session created successfully!')
    return NextResponse.json({ user: userData, session: signInData.session })
  } catch (error) {
    console.error('‚ùå [verify-token] Unexpected error:', error)
    return NextResponse.json(
      { error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ç–æ–∫–µ–Ω–∞', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    )
  }
}
