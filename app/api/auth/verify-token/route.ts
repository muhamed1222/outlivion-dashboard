import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

export const dynamic = 'force-dynamic'

function getSupabaseClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: {
        autoRefreshToken: false,
        persistSession: false,
      },
    }
  )
}

export async function POST(request: NextRequest) {
  try {
    console.log('üîç [verify-token] Starting token verification...')
    const supabase = getSupabaseClient()
    const { token } = await request.json()
    console.log('üìù [verify-token] Token received:', token ? `${token.substring(0, 8)}...` : 'null')

    if (!token) {
      console.error('‚ùå [verify-token] No token provided')
      return NextResponse.json({ error: '–¢–æ–∫–µ–Ω –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω' }, { status: 400 })
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–∫–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    console.log('üîé [verify-token] Looking up token in database...')
    const { data: authToken, error: tokenError } = await supabase
      .from('auth_tokens')
      .select('*')
      .eq('token', token)
      .single()

    if (tokenError) {
      console.error('‚ùå [verify-token] Token lookup error:', tokenError)
      return NextResponse.json({ error: '–ù–µ–≤–µ—Ä–Ω—ã–π –∏–ª–∏ –∏—Å—Ç–µ–∫—à–∏–π —Ç–æ–∫–µ–Ω', details: tokenError.message }, { status: 401 })
    }

    if (!authToken) {
      console.error('‚ùå [verify-token] Token not found')
      return NextResponse.json({ error: '–ù–µ–≤–µ—Ä–Ω—ã–π –∏–ª–∏ –∏—Å—Ç–µ–∫—à–∏–π —Ç–æ–∫–µ–Ω' }, { status: 401 })
    }

    console.log('‚úÖ [verify-token] Token found:', { telegram_id: authToken.telegram_id, used: authToken.used, expires_at: authToken.expires_at })

    if (authToken.used) {
      console.error('‚ùå [verify-token] Token already used')
      return NextResponse.json({ error: '–¢–æ–∫–µ–Ω —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω' }, { status: 401 })
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∏—Å—Ç—ë–∫ –ª–∏ —Ç–æ–∫–µ–Ω
    if (new Date(authToken.expires_at) < new Date()) {
      console.error('‚ùå [verify-token] Token expired:', authToken.expires_at)
      return NextResponse.json({ error: '–¢–æ–∫–µ–Ω –∏—Å—Ç—ë–∫' }, { status: 401 })
    }

    console.log('‚úÖ [verify-token] Token is valid, proceeding...')

    const email = `${authToken.telegram_id}@outlivion.local`
    console.log('üìß [verify-token] Generated email:', email)

    console.log('üîé [verify-token] Checking existing profile...')
    const { data: existingProfileByTelegram, error: profileFetchError } = await supabase
      .from('users')
      .select('*')
      .eq('telegram_id', authToken.telegram_id)
      .maybeSingle()

    if (profileFetchError) {
      console.error('‚ùå [verify-token] Profile fetch error:', profileFetchError)
      return NextResponse.json(
        { error: '–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –ø—Ä–æ—Ñ–∏–ª—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', details: profileFetchError.message },
        { status: 500 }
      )
    }

    console.log('‚úÖ [verify-token] Profile check done:', existingProfileByTelegram ? `Found user ${existingProfileByTelegram.id}` : 'No existing profile')

    type AdminUser = NonNullable<
      Awaited<ReturnType<typeof supabase.auth.admin.getUserById>>['data']['user']
    >

    let authUser: AdminUser | null = null
    let createdAuthUser = false

    if (existingProfileByTelegram?.id) {
      console.log('üîç [verify-token] Checking auth.users for existing profile ID:', existingProfileByTelegram.id)
      const { data: existingAuthUser } = await supabase.auth.admin.getUserById(existingProfileByTelegram.id)
      authUser = existingAuthUser?.user ?? null
      console.log('‚úÖ [verify-token] Auth user check:', authUser ? 'Found' : 'Not found')
    }

    if (!authUser) {
      console.log('üÜï [verify-token] Creating new auth user with email:', email)
      const { data: createdAuthResponse, error: authCreateError } = await supabase.auth.admin.createUser({
        email,
        password: token,
        email_confirm: true,
        user_metadata: {
          telegram_id: authToken.telegram_id,
        },
      })

      if (authCreateError) {
        console.error('‚ùå [verify-token] Auth creation error details:', {
          message: authCreateError.message,
          status: authCreateError.status,
          code: authCreateError.code,
        })
        if (authCreateError.message?.toLowerCase().includes('already registered')) {
          console.log('üîç [verify-token] User already registered, searching...')
          let matchedUser: AdminUser | null = null

          const admin = supabase.auth.admin as {
            listUsers: typeof supabase.auth.admin.listUsers
            getUserByEmail?: (email: string) => Promise<{
              data: { user: AdminUser | null } | null
              error: { message: string } | null
            }>
          }

          if (typeof admin.getUserByEmail === 'function') {
            const { data: emailUser, error: emailLookupError } = await admin.getUserByEmail(email)
            if (emailLookupError) {
              console.error('Auth getUserByEmail error:', emailLookupError)
            }
            matchedUser = emailUser?.user ?? null
          }

          if (!matchedUser) {
            const { data: listData, error: listError } = await supabase.auth.admin.listUsers({ page: 1, perPage: 2000 })
            if (listError) {
              console.error('Auth list users error:', listError)
            }
            matchedUser = (listData?.users.find(
              (user) =>
                user.email?.toLowerCase() === email.toLowerCase() ||
                user.user_metadata?.telegram_id === authToken.telegram_id
            ) ?? null) as AdminUser | null
          }

          if (matchedUser) {
            authUser = matchedUser
            console.log('‚úÖ [verify-token] Found existing auth user:', authUser.id)
          } else {
            console.error('‚ùå [verify-token] Auth user lookup error after conflict:', authCreateError)
            return NextResponse.json(
              { error: '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', details: authCreateError.message },
              { status: 500 }
            )
          }
        } else {
          console.error('‚ùå [verify-token] Auth creation error:', authCreateError)
          return NextResponse.json({ error: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', details: authCreateError.message }, { status: 500 })
        }
      } else if (createdAuthResponse?.user) {
        authUser = createdAuthResponse.user
        createdAuthUser = true
        console.log('‚úÖ [verify-token] Auth user created:', authUser.id)
      }
    }

    if (!authUser) {
      console.error('‚ùå [verify-token] No auth user after all attempts')
      return NextResponse.json({ error: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' }, { status: 500 })
    }

    console.log('‚úÖ [verify-token] Auth user ready:', authUser.id)

    if (!createdAuthUser) {
      const { error: updatePasswordError } = await supabase.auth.admin.updateUserById(authUser.id, {
        password: token,
        user_metadata: {
          telegram_id: authToken.telegram_id,
        },
      })

      if (updatePasswordError) {
        console.error('Auth update error:', updatePasswordError)
      }
    }

    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ—Ñ–∏–ª—å –≤ —Ç–∞–±–ª–∏—Ü–µ users
    let userData = null

    if (existingProfileByTelegram) {
      userData = existingProfileByTelegram
    }

    if (existingProfileByTelegram) {
      if (existingProfileByTelegram.id !== authUser.id) {
        const oldId = existingProfileByTelegram.id

        const relationsToUpdate = [
          { table: 'codes', column: 'used_by' },
          { table: 'referrals', column: 'referrer_id' },
          { table: 'referrals', column: 'referred_id' },
          { table: 'transactions', column: 'user_id' },
          { table: 'payments', column: 'user_id' },
        ]

        for (const relation of relationsToUpdate) {
          const { error: relationError } = await supabase
            .from(relation.table)
            .update({ [relation.column]: authUser.id })
            .eq(relation.column, oldId)

          if (relationError) {
            console.error(`Failed to migrate ${relation.table}.${relation.column}`, relationError)
            return NextResponse.json(
              { error: '–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' },
              { status: 500 }
            )
          }
        }

        const { data: migratedProfile, error: migrateError } = await supabase
          .from('users')
          .update({ id: authUser.id })
          .eq('id', oldId)
          .select()
          .single()

        if (migrateError) {
          console.error('Profile migration error:', migrateError)
          return NextResponse.json(
            { error: '–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' },
            { status: 500 }
          )
        }

        userData = migratedProfile
      } else {
        userData = existingProfileByTelegram
      }
    } else {
      const { data: createdProfile, error: createProfileError } = await supabase
        .from('users')
        .insert({
          id: authUser.id,
          telegram_id: authToken.telegram_id,
        })
        .select()
        .single()

      if (createProfileError || !createdProfile) {
        console.error('Profile creation error:', createProfileError)
        return NextResponse.json(
          { error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' },
          { status: 500 }
        )
      }

      userData = createdProfile
    }

    // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ telegram_id –∞–∫—Ç—É–∞–ª–µ–Ω
    if (userData.telegram_id !== authToken.telegram_id) {
      const { data: alignedProfile, error: alignError } = await supabase
        .from('users')
        .update({ telegram_id: authToken.telegram_id })
        .eq('id', authUser.id)
        .select()
        .single()

      if (!alignError && alignedProfile) {
        userData = alignedProfile
      }
    }

    // –ü–æ–º–µ—á–∞–µ–º —Ç–æ–∫–µ–Ω –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π
    console.log('üîÑ [verify-token] Marking token as used...')
    await supabase
      .from('auth_tokens')
      .update({ used: true })
      .eq('token', token)

    console.log('üîê [verify-token] Creating session for user...')
    // –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏—Å–ø–æ–ª—å–∑—É—è –ø–∞—Ä–æ–ª—å = —Ç–æ–∫–µ–Ω
    const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({
      email: authUser.email!,
      password: token,
    })

    if (signInError || !signInData.session) {
      console.error('‚ùå [verify-token] Failed to create session:', signInError)
      return NextResponse.json(
        { error: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å–µ—Å—Å–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', details: signInError?.message },
        { status: 500 }
      )
    }

    console.log('‚úÖ [verify-token] Session created successfully!')
    return NextResponse.json({ user: userData, session: signInData.session })
  } catch (error) {
    console.error('‚ùå [verify-token] Unexpected error:', error)
    return NextResponse.json(
      { error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ç–æ–∫–µ–Ω–∞', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    )
  }
}
